unit RoomStuff;interface	uses		Palettes, Globals, Utilities, Drawing;	procedure SortObjects;	function InsertNewRoom: Boolean;	procedure FlushRoom (var whichRoom: roomData);	procedure DoGotoDial;	function roomFltr (theDlg: DialogPtr; var theEvnt: EventRecord; var itemHit: integer): boolean;	procedure DoRoomBackInfo (var shouldOpen: Boolean);	procedure DoRoomCondInfo (var shouldOpen: Boolean);implementation	const		roomCondID = 129;		roomBackID = 130;	var		tempTile: array[0..7] of Integer;		backNumber: Integer;{=================================}	procedure SortObjects;		var			holdActive, i, count, itemType: Integer;			holdRoom: RoomData;	begin		FlushRoom(holdRoom);		count := 0;		holdActive := oneActive;		for i := 1 to 16 do		begin			itemType := thisRoom.theObjects[i].objectIs;			if ((itemType <> paintg) and (itemType <> mirror) and (itemType <> window) and (itemType <> 0)) then			begin				count := count + 1;				if (oneActive = i) then					holdActive := count;				holdRoom.theObjects[count] := thisRoom.theObjects[i];				thisRoom.theObjects[i].objectIs := 0;			end;		end;		for i := 1 to 16 do		begin			itemType := thisRoom.theObjects[i].objectIs;			if (itemType <> 0) then			begin				count := count + 1;				if (oneActive = i) then					holdActive := count;				holdRoom.theObjects[count] := thisRoom.theObjects[i];			end;		end;		for i := 1 to thisRoom.numberOObjects do			thisRoom.theObjects[i] := holdRoom.theObjects[i];		with thisRoom do			if (count <> numberOObjects) then	{*** Check for agreement}			begin				count := 0;						{*** Run a second check}				for i := 1 to 16 do					if (theObjects[i].objectIs <> 0) then						count := count + 1;				numberOObjects := count;			{*** We'll go with this #}				if (numberOObjects < 16) then					for i := numberOObjects + 1 to 16 do					begin						theObjects[i].objectIs := 0;	{*** Zero-out excess fields}						theObjects[i].boundRect := nullRect;						theObjects[i].amount := 0;						theObjects[i].extra := 0;						theObjects[i].isOn := FALSE;					end;			end;		oneActive := holdActive;				{*** Restore active object}	end;{=================================}	function InsertNewRoom;		var			i: Integer;	begin		InsertNewRoom := FALSE;		if (thisHouse.numberORooms >= 40) then				{trying to add 41 rooms}		begin			GenericAlert(kErrTooManyRooms);			Exit(InsertNewRoom);		end;		thisHouse.theRooms[roomAt] := thisRoom;				{insert room to date}		if (roomAt < thisHouse.numberORooms) then			{shift only if in middle}			for i := thisHouse.numberORooms downto roomAt + 1 do				thisHouse.theRooms[i + 1] := thisHouse.theRooms[i];	{shift rooms right}		roomAt := roomAt + 1;							{kick active over to right}		FlushRoom(thisRoom);								{flush new room copy}		thisHouse.theRooms[roomAt] := thisRoom;				{copy active into house}		thisHouse.numberORooms := thisHouse.numberORooms + 1;	{one more room}		InsertNewRoom := TRUE;	end;{=================================}	procedure FlushRoom;		var			index: Integer;			defaultName: Str255;	begin		NumToString(roomAt, defaultName);		defaultName := CONCAT('Room # ', defaultName);		with whichRoom do		begin			roomName := defaultName;			numberOObjects := 0;			backPictID := 200;			for index := 0 to 7 do				tileOrder[index] := 0;			animateKind := 0;			animateNumber := 0;			animateDelay := 0;			conditionCode := 0;			for index := 1 to 16 do			begin				theObjects[index].objectIs := 0;				theObjects[index].boundRect := nullRect;				theObjects[index].amount := 0;				theObjects[index].extra := 0;				theObjects[index].isOn := FALSE;			end;		end;	end;{=================================}	procedure DoGotoDial;		const			okayBut = 1;			cancelBut = 2;			gotoEdit = 3;			numOfStat = 4;			currStat = 5;		var			leaveDlg: Boolean;			tempLong: LongInt;			theDlgPtr: DialogPtr;			tempRect: Rect;			cntlType, index, itemHit, tempInt, rightOff, downOff: Integer;			dlgItem: Handle;			cntlHand, tempCntlHand: controlhandle;			strTemp: Str255;{-------------------------}		procedure Redraw;			var				index: Integer;		begin			SetPort(theDlgPtr);     		{Point to our dialog window}			GetDItem(theDlgPtr, okayBut, cntlType, dlgItem, tempRect);{Get the item handle}			PenSize(3, 3);  				{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);     	{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenNormal;		end;{-------------------------}	begin		theDlgPtr := GetNewDialog(261, nil, Pointer(-1));		with theDlgPtr^.portBits do		begin			rightOff := rightOffset - bounds.left;			downOff := downOffset - bounds.top;		end;		MoveWindow(theDlgPtr, rightOff, downOff, FALSE);		ShowWindow(theDlgPtr);		SelectWindow(theDlgPtr);		SetPort(theDlgPtr);		with thisHouse do		begin			NumToString(numberORooms, strTemp);			GetDItem(theDlgPtr, numOfStat, cntlType, dlgItem, tempRect);			SetIText(dlgItem, strTemp);		end;		NumToString(roomAt, strTemp);		GetDItem(theDlgPtr, currStat, cntlType, dlgItem, tempRect);		SetIText(dlgItem, strTemp);		NumToString(roomAt, strTemp);		GetDItem(theDlgPtr, gotoEdit, cntlType, dlgItem, tempRect);		SetIText(dlgItem, strTemp);		SelIText(theDlgPtr, gotoEdit, 0, 3);		Redraw;		leaveDlg := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDItem(theDlgPtr, itemHit, cntlType, dlgItem, tempRect);			if (itemHit = okayBut) then			begin				GetDItem(theDlgPtr, gotoEdit, cntlType, dlgItem, tempRect);				GetIText(dlgItem, strTemp);	{Get the text entered}				StringToNum(strTemp, tempLong);				if ((LoWord(tempLong) > 0) and (LoWord(tempLong) < thisHouse.numberORooms + 1)) then				begin					leaveDlg := TRUE;					roomAt := LoWord(tempLong);				end				else				begin					SysBeep(1);					NumToString(roomAt, strTemp);					GetDItem(theDlgPtr, gotoEdit, cntlType, dlgItem, tempRect);					SetIText(dlgItem, strTemp);					SelIText(theDlgPtr, gotoEdit, 0, 3);				end;			end;			if (itemHit = cancelBut) then			begin				leaveDlg := TRUE;			end;		until leaveDlg;		DisposDialog(theDlgPtr);		if (toolWndo <> nil) then			SetPort(toolWndo)		else			SetPort(mainWndo);	end;{=================================}	function roomFltr;		var			cntlType, index, whichTile, itemDropped: Integer;			wasPt, newPt: Point;			dlgItem: Handle;			thePict: PicHandle;			tempRect, sameRect, dest, tempRect2: Rect;			tempByte: SignedByte;{----------------}		procedure ClickedInLeftBox;			var				index2: Integer;		begin			whichTile := (wasPt.h - 17) div 8;			SetRect(tempRect, 0, 0, 8, 49);		{a tile rect}			OffsetRect(tempRect, 17 + (whichTile * 8), 83);			GetMouse(wasPt);			newPt := wasPt;			PenPat(gray);			PenMode(patXOr);			FrameRect(tempRect);			while (WaitMouseUp) do			begin				GetMouse(newPt);				if (newPt.h <> wasPt.h) then				begin					FrameRect(tempRect);					OffsetRect(tempRect, newPt.h - wasPt.h, 0);					FrameRect(tempRect);					wasPt := newPt;				end;							{end - if (a)}			end;							{end - while}			FrameRect(tempRect);			PenNormal;			SetRect(dest, 111, 83, 175, 132);			if (PtInRect(newPt, dest)) then			begin				itemDropped := (newPt.h - 111) div 8;				if ((itemDropped > -1) and (itemDropped < 8)) then					tempTile[itemDropped] := whichTile				else					SysBeep(1);			end;			for index2 := 0 to 7 do			begin				SetRect(tempRect, 0, 0, 8, 49);				OffsetRect(tempRect, 111 + (index2 * 8), 83);				thePict := GetPicture(300 + tempTile[index2] + (backNumber * 8));				if (thePict <> nil) then				begin					tempByte := HGetState(Handle(thePict));					HLock(Handle(thePict));					DrawPicture(thePict, tempRect);					HSetState(Handle(thePict), tempByte);				end				else				begin					GenericAlert(kErrGraphicLoad);				end;				ReleaseResource(Handle(thePict));			end;						{end - for}		end;							{end - if PtInRect}{----------------}	begin		roomFltr := FALSE;	{assume no events}		if ((theEvnt.what = KeyDown) and (BitAnd(theEvnt.message, CharCodeMask) = $0D)) then		begin				{'carriage' return hit}			itemHit := 1;			roomFltr := TRUE;		end;		if (theEvnt.what = MouseDown) then		begin			GetMouse(wasPt);			SetRect(tempRect, 17, 83, 81, 132);			if (PtInRect(wasPt, tempRect)) then	{tempRect => left tile rect}				ClickedInLeftBox;		end;							{end - if mouseDown}		SetRect(tempRect2, 17, 78, 81, 81);	{erase any old markers}		EraseRect(tempRect2);		SetRect(tempRect2, 17, 134, 81, 137);		EraseRect(tempRect2);		GetMouse(wasPt);		SetRect(tempRect, 17, 83, 81, 132);		if (PtInRect(wasPt, tempRect)) then	{tempRect => left tile rect}		begin			whichTile := (wasPt.h - 17) div 8;			SetRect(tempRect, 0, 0, 8, 49);		{a tile rect}			OffsetRect(tempRect, 17 + (whichTile * 8), 83);			tempRect2 := tempRect;			{draw top marker over tile}			tempRect2.top := tempRect2.top - 5;			tempRect2.bottom := tempRect2.top + 3;			ForeColor(redColor);			PaintRect(tempRect2);			ForeColor(blackColor);			tempRect2 := tempRect;			{draw bottom marker under tile}			tempRect2.bottom := tempRect2.bottom + 5;			tempRect2.top := tempRect2.bottom - 3;			ForeColor(redColor);			PaintRect(tempRect2);			ForeColor(blackColor);		end;	end;{=================================}	procedure DoRoomBackInfo;		const			okayBut = 1;			cancelBut = 2;			backIcon1 = 3;			backIcon10 = 12;			backStat = 13;			tileStat = 14;		var			wasPort: GrafPtr;			leaveDlg: Boolean;			theDlgPtr: DialogPtr;			tempRect, wasRect: Rect;			cntlType, i, i2, itemHit, tempInt, rightOff, downOff: Integer;			dlgItem: Handle;			strTemp: Str255;			backName: array[0..9] of string[18];			thePict: PicHandle;			tempRoom: roomData;{-------------------------}		procedure Redraw;			var				i, width: Integer;				tempByte: SignedByte;		begin			SetPort(theDlgPtr);     		{Point to our dialog window}			GetDItem(theDlgPtr, okayBut, cntlType, dlgItem, tempRect);{Get the item handle}			PenSize(3, 3);  				{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);     	{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			GetDItem(theDlgPtr, backNumber + backIcon1, cntlType, dlgItem, tempRect);			PenSize(2, 2);			InsetRect(tempRect, -2, -2);			ForeColor(redColor);			FrameRect(tempRect);			ForeColor(blackColor);			wasRect := tempRect;			PenNormal;			with theDlgPtr^.portRect do				width := right - left;			MoveTo(4, 38);			Line(width - 8, 0);			MoveTo(4, 40);			Line(width - 8, 0);			for i := 0 to 7 do			begin				SetRect(tempRect, 0, 0, 8, 49);				OffsetRect(tempRect, 111 + (i * 8), 83);				thePict := GetPicture(300 + tempTile[i] + (backNumber * 8));				if (thePict <> nil) then				begin					tempByte := HGetState(Handle(thePict));					HLock(Handle(thePict));					DrawPicture(thePict, tempRect);					HSetState(Handle(thePict), tempByte);				end				else				begin					GenericAlert(kErrGraphicLoad);				end;				ReleaseResource(Handle(thePict));			end;			for i := 0 to 7 do			begin				SetRect(tempRect, 0, 0, 8, 49);				OffsetRect(tempRect, 17 + (i * 8), 83);				thePict := GetPicture(300 + i + (backNumber * 8));				if (thePict <> nil) then				begin					tempByte := HGetState(Handle(thePict));					HLock(Handle(thePict));					DrawPicture(thePict, tempRect);					HSetState(Handle(thePict), tempByte);				end				else				begin					GenericAlert(kErrGraphicLoad);				end;				ReleaseResource(Handle(thePict));			end;			ForeColor(redColor);			SetRect(tempRect, 15, 81, 83, 134);			FrameRect(tempRect);			ForeColor(blueColor);			SetRect(tempRect, 109, 81, 177, 134);			FrameRect(tempRect);			ForeColor(blackColor);		end;{-------------------------}	begin		GetPort(wasPort);		theDlgPtr := GetNewDialog(roomBackID, nil, Pointer(-1));		if (theDlgPtr = nil) then		begin			GenericAlert(kErrLoadingRes);			Exit(DoRoomBackInfo);		end;		with theDlgPtr^.portBits do		begin			rightOff := rightOffset - bounds.left;			downOff := downOffset - bounds.top;		end;		MoveWindow(theDlgPtr, rightOff, downOff, FALSE);		ShowWindow(theDlgPtr);		SelectWindow(theDlgPtr);		SetPort(theDlgPtr);		backName[0] := 'Plain Room';		backName[1] := 'Paneled Room';		backName[2] := 'Basement';		backName[3] := 'Japanese Room';		backName[4] := 'Child’s Room';		backName[5] := 'Unfinished Room';		backName[6] := 'Hip Wallpaper';		backName[7] := 'Entertainment';		backName[8] := 'Bathroom';		backName[9] := 'Kitchen';		tempRoom := thisRoom;		with tempRoom do		begin			backNumber := backPictID - 200;			for i := 0 to 7 do				tempTile[i] := tileOrder[i];			GetDItem(theDlgPtr, backStat, cntlType, dlgItem, tempRect);			SetIText(dlgItem, backName[backNumber]);		end;		if (not shouldOpen) then			HideDItem(theDlgPtr, cancelBut);		Redraw;		leaveDlg := FALSE;		shouldOpen := FALSE;		repeat			ModalDialog(@roomFltr, itemHit);			GetDItem(theDlgPtr, itemHit, cntlType, dlgItem, tempRect);			for i := backIcon1 to backIcon10 do				if (itemHit = i) then				begin					PenSize(2, 2);					PenPat(white);					FrameRect(wasRect);					GetDItem(theDlgPtr, i, cntlType, dlgItem, tempRect);					InsetRect(tempRect, -2, -2);					PenPat(black);					ForeColor(redColor);					FrameRect(tempRect);					ForeColor(blackColor);					wasRect := tempRect;					PenNormal;					backNumber := i - backIcon1;					GetDItem(theDlgPtr, backStat, cntlType, dlgItem, tempRect);					SetIText(dlgItem, backName[backNumber]);					tempRoom.backPictID := backNumber + 200;					for i2 := 0 to 7 do						case backNumber of							0..3, 5: 								tempTile[i2] := 0;							otherwise								tempTile[i2] := i2						end;					Redraw;				end;			if (itemHit = okayBut) then			begin				leaveDlg := TRUE;				changed := TRUE;				with tempRoom do				begin					for i := 0 to 7 do					begin						tileOrder[i] := tempTile[i];					end;					case backPictId of						200..203, 205: 						begin							if (tileOrder[0] = 6) then	{don't allow backward walls}								tileOrder[0] := 0;							if (tileOrder[7] = 7) then								tileOrder[7] := 0;							if (tileOrder[0] = 7) then	{check left open}								leftOpen := FALSE							else								leftOpen := TRUE;							if (tileOrder[7] = 6) then	{check right open}								rightOpen := FALSE							else								rightOpen := TRUE;							for i := 1 to 6 do			{don't allow walls in the middle}								if ((tileOrder[i] = 6) or (tileOrder[i] = 7)) then								begin									SysBeep(1);									tileOrder[i] := 0;								end;						end;						otherwise						begin							leftOpen := TRUE;							rightOpen := TRUE;						end;					end;			{end - case}					if (roomAt = 1) then						leftOpen := FALSE;				end;			{end - with}				if (leaveDlg) then				begin					thisRoom := tempRoom;				end;			end;			if (itemHit = cancelBut) then			begin				if (thisHouse.numberORooms < 1) then					shouldOpen := TRUE;				leaveDlg := TRUE;			end;		until leaveDlg;		DisposDialog(theDlgPtr);		if (toolWndo <> nil) then			SetPort(toolWndo)		else			SetPort(wasPort);	end;{=================================}{=================================}	procedure DoRoomCondInfo;		const			inactive = 255;			active = 0;			okayBut = 1;			cancelBut = 2;			normalRadio = 3;			lightsRadio = 5;			nothingRadio = 6;			dartsRadio = 9;			numOfEdit = 10;			delayEdit = 11;			nameEdit = 12;			objectsStat = 13;			roomNumStat = 14;		var			leaveDlg: Boolean;			theDlgPtr: DialogPtr;			tempRect, wasRect: Rect;			cntlType, itemHit, tempInt, rightOff, downOff, i: Integer;			tempLong: LongInt;			dlgItem: Handle;			strTemp: Str255;			wasPort: GrafPtr;			tempRoom: roomData;{-------------------------}		procedure Redraw;			var				width: Integer;		begin			SetPort(theDlgPtr);     		{Point to our dialog window}			GetDItem(theDlgPtr, okayBut, cntlType, dlgItem, tempRect);{Get the item handle}			PenSize(3, 3);  				{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);     	{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenNormal;			with theDlgPtr^.portRect do				width := right - left;			MoveTo(4, 38);			Line(width - 8, 0);			MoveTo(4, 40);			Line(width - 8, 0);		end;{-------------------------}	begin		GetPort(wasPort);		theDlgPtr := GetNewDialog(roomCondID, nil, Pointer(-1));		if (theDlgPtr = nil) then		begin			GenericAlert(kErrLoadingRes);			Exit(DoRoomCondInfo);		end;		with theDlgPtr^.portBits do		begin			rightOff := rightOffset - bounds.left;			downOff := downOffset - bounds.top;		end;		MoveWindow(theDlgPtr, rightOff, downOff, FALSE);		ShowWindow(theDlgPtr);		SelectWindow(theDlgPtr);		SetPort(theDlgPtr);		tempRoom := thisRoom;		with tempRoom do		begin{pop name of room into edit text field}			GetDItem(theDlgPtr, nameEdit, cntlType, dlgItem, tempRect);			strTemp := roomName;			SetIText(dlgItem, strTemp);{pop the room number as static text}			GetDItem(theDlgPtr, roomNumStat, cntlType, dlgItem, tempRect);			NumToString(roomAt, strTemp);			SetIText(dlgItem, strTemp);{pop up number of animates into edit text field}			GetDItem(theDlgPtr, numOfEdit, cntlType, dlgItem, tempRect);			NumToString(animateNumber, strTemp);			SetIText(dlgItem, strTemp);{pop up delay - convert to seconds}			GetDItem(theDlgPtr, delayEdit, cntlType, dlgItem, tempRect);			NumToString(animateDelay, strTemp);			SetIText(dlgItem, strTemp);{pop up number of objects as static text}			GetDItem(theDlgPtr, objectsStat, cntlType, dlgItem, tempRect);			NumToString(numberOObjects, strTemp);			SetIText(dlgItem, strTemp);{select radio button representing animate kind}			if (animateNumber > 0) then			begin				tempInt := 9 - animateKind;				GetDItem(theDlgPtr, tempInt, cntlType, dlgItem, tempRect);				SetCtlValue(ControlHandle(dlgItem), 1);			end			else			begin				GetDItem(theDlgPtr, nothingRadio, cntlType, dlgItem, tempRect);				SetCtlValue(ControlHandle(dlgItem), 1);			end;{select radio button representing condition of room}			GetDItem(theDlgPtr, conditionCode + 3, cntlType, dlgItem, tempRect);			SetCtlValue(ControlHandle(dlgItem), 1);{decide whether or not to gray out cancel button}			if (not shouldOpen) then			begin				GetDItem(theDlgPtr, cancelBut, cntlType, dlgItem, tempRect);				HiliteControl(ControlHandle(dlgItem), inactive);			end;		end;	{end - with tempRoom do}{select the name of the room}		SelIText(theDlgPtr, nameEdit, 0, 24);		Redraw;		leaveDlg := FALSE;		shouldOpen := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDItem(theDlgPtr, itemHit, cntlType, dlgItem, tempRect);			for i := normalRadio to lightsRadio do				if (itemHit = i) then				begin					for tempInt := normalRadio to lightsRadio do					begin						GetDItem(theDlgPtr, tempInt, cntlType, dlgItem, tempRect);						SetCtlValue(ControlHandle(dlgItem), 0);					end;					GetDItem(theDlgPtr, i, cntlType, dlgItem, tempRect);					SetCtlValue(ControlHandle(dlgItem), 1);					tempRoom.conditionCode := i - normalRadio;				end;			for i := nothingRadio to dartsRadio do				if (itemHit = i) then				begin					for tempInt := nothingRadio to dartsRadio do					begin						GetDItem(theDlgPtr, tempInt, cntlType, dlgItem, tempRect);						SetCtlValue(ControlHandle(dlgItem), 0);					end;					GetDItem(theDlgPtr, i, cntlType, dlgItem, tempRect);					SetCtlValue(ControlHandle(dlgItem), 1);					if (itemHit = nothingRadio) then					begin						tempRoom.animateNumber := 0;						GetDItem(theDlgPtr, numOfEdit, cntlType, dlgItem, tempRect);						NumToString(tempRoom.animateNumber, strTemp);						SetIText(dlgItem, strTemp);					end					else					begin						tempRoom.animateKind := 9 - i;					end;				end;			if (itemHit = okayBut) then			begin				leaveDlg := TRUE;				with tempRoom do				begin					GetDItem(theDlgPtr, numOfEdit, cntlType, dlgItem, tempRect);					GetIText(dlgItem, strTemp);	{Get the text entered}					StringToNum(strTemp, tempLong);					tempRoom.animateNumber := LoWord(tempLong);					if (tempRoom.animateNumber < 0) then					begin						SysBeep(1);						leaveDlg := FALSE;						tempInt := -tempRoom.animateNumber;						if (tempInt > 16) then							tempInt := 16;						NumToString(tempInt, strTemp);						SetIText(dlgItem, strTemp);					end;					if (tempRoom.animateNumber > 16) then					begin						SysBeep(1);						leaveDlg := FALSE;						NumToString(16, strTemp);						SetIText(dlgItem, strTemp);					end;					GetDItem(theDlgPtr, delayEdit, cntlType, dlgItem, tempRect);					GetIText(dlgItem, strTemp);	{Get the text entered}					StringToNum(strTemp, tempLong);					tempRoom.animateDelay := LoWord(tempLong);					if (tempRoom.animateDelay < 0) then					begin						SysBeep(1);						leaveDlg := FALSE;						tempInt := -tempRoom.animateDelay;						if (tempInt > 16) then							tempInt := 16;						NumToString(tempInt, strTemp);						SetIText(dlgItem, strTemp);					end;					GetDItem(theDlgPtr, nameEdit, cntlType, dlgItem, tempRect);					GetIText(dlgItem, strTemp);	{Get the text entered}					if (LENGTH(strTemp) > 24) then						strTemp := COPY(strTemp, 1, 24);					tempRoom.roomName := strTemp;				end;	{end - with tempRoom}				if (leaveDlg) then				begin					changed := TRUE;					thisRoom := tempRoom;					DrawRoomNum;				end;			end;			if (itemHit = cancelBut) then			begin				if (thisHouse.numberORooms < 1) then					shouldOpen := TRUE;				leaveDlg := TRUE;			end;		until leaveDlg;		DisposDialog(theDlgPtr);		if (toolWndo <> nil) then			SetPort(toolWndo)		else			SetPort(wasPort);	end;{=================================}end.