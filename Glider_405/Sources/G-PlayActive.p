unit PlayActive;interface	uses		SMS, Palettes, Globals, GlobalUtils, FileInNOut, PlayUtils, PlaySetUp;	procedure Coordinate;	var		timeIs: LongInt;		hotRect: Rect;		sliding: Boolean;{=================================}implementation{=================================}	procedure CenterMouse;		const			MBState = $172;			MTemp = $828;			RawMouse = $82C;			Mouse = $830;			CrsrNew = $8CE;			CrsrCouple = $8CF;			Couple = $FF;			Uncouple = $00;		var			center: Point;			lowGlob: Integer;			lowMem: Ptr;			pointPtr: ^Point;	begin		SetPt(center, 256, 171);		lowMem := Pointer(rawMouse);		pointPtr := @lowMem^;		pointPtr^ := center;		lowMem := Pointer(MTemp);		pointPtr := @lowMem^;		pointPtr^ := center;		lowMem := Pointer(CrsrNew);		lowMem^ := $FFFF;	end;{=================================}	procedure IncInt (var i: integer);	inline		$205F, {MOVEA.W (A7)+, A0 }		$5250; {ADDQ.W #$1, (A0) }{=================================}	procedure IncLong (var l: longint);	inline		$205F, {MOVEA.L (A7)+, A0 }		$5290; {ADDQ.L #$1, (A0) }{=================================}	procedure FloatTheScore (whatPoints: Integer);		var			tempStr: Str255;	begin		with floatPoints do		begin			if (out) then			begin				if (inColor) then					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, whereR, whereR, srcCopy, wholeRgn)				else					CopyBits(offVirginMap, mainWndo^.portBits, whereR, whereR, srcCopy, wholeRgn);				if (areFlipping) then					CopyBits(offVirginMap, offLoadMap, whereR, whereR, srcCopy, wholeRgn);			end;			out := TRUE;			whereR := theGlider.destRect;			if (inColor) then				whereR.top := whereR.bottom			else				whereR.top := whereR.top - 30;			whereR.bottom := whereR.top + 12;			NumToString(whatPoints, tempStr);			saysWhat := tempStr;			SetPort(GrafPtr(mainWndo));			if (inColor) then			begin				PenNormal;				TextFont(16);				TextSize(12);				MoveTo(whereR.left, whereR.bottom - 2);				RGBForeColor(rgbYellow);				PenMode(srcOr);				DrawString(saysWhat);				PenNormal;				RGBForeColor(rgbBlack);				tickStamp := TickCount + 120;				SetPort(GrafPtr(virginCPtr))			end			else			begin				TextFont(201);				TextMode(patBic);				MoveTo(whereR.left, whereR.bottom - 2);				DrawString(tempStr);				TextFont(200);				TextMode(patOr);				MoveTo(whereR.left, whereR.bottom - 2);				DrawString(tempStr);				tickStamp := TickCount + 120;				PenNormal;				SetPort(offVirginPort);			end;			if (areFlipping) then			begin				SetPort(offLoadPort);				TextFont(201);				TextMode(patBic);				MoveTo(whereR.left, whereR.bottom - 2);				DrawString(tempStr);				TextFont(200);				TextMode(patOr);				MoveTo(whereR.left, whereR.bottom - 2);				DrawString(tempStr);				tickStamp := TickCount + 120;				PenNormal;				SetPort(offVirginPort);			end;		end;	end;{=================================}	procedure Collision (whatKind, who: Integer);		var			tempStr: Str255;			tempRect, srcR, destReserve: Rect;			tempInt: Integer;	begin		case (whatKind) of			ignoreIt: 				;			crashIt: 			begin				lifeNormal := FALSE;				with theGlider do				begin					DoTheSound(1);					mode := fadingOut;					destRect.top := destRect.bottom - 20;					if (isForward) then						srcNum := 0					else						srcNum := 2;				end;			end;			liftIt: 				if (not airOut) then					liftAmount := -7;			dropIt: 				if (not airOut) then					liftAmount := 7;			moveIt: 			begin				DoTheSound(16);				Transport(eventKind[who, 1]);				hotRect := nullRect;			{don't die in rest of SearchRects}			end;			turnItLeft: 			begin				shiftAmount := -7;				if (lifeNormal) then					with theGlider do						if (isRight) then						begin							lifeNormal := FALSE;							theGlider.mode := turnRt2Lf;						end;			end;			turnItRight: 			begin				shiftAmount := 7;				if (lifeNormal) then					with theGlider do						if (not isRight) then						begin							lifeNormal := FALSE;							theGlider.mode := turnLf2Rt;						end;			end;			burnIt: 			begin				liftAmount := -7;				if ((lifeNormal) and (theGlider.destRect.bottom > eventKind[who, 1])) then					with theGlider do					begin						DoTheSound(8);						lifeNormal := FALSE;						if (isRight) then							phase := 1;						mode := burning;						timeStamp := TickCount + 300;						destRect.top := destRect.bottom - 36;					end;			end;			awardIt:		{clock}				if (eventKind[who, 1] <> 0) then				begin					DoTheSound(5);					StartScoreRolling;					suppScore := suppScore + eventKind[who, 1];					FloatTheScore(eventKind[who, 1]);					eventKind[who, 1] := 0;					thisHouse.theRooms[roomAt].theObjects[who].amount := 0;					destReserve := eventRect[who];					OffsetRect(destReserve, -destReserve.left, -destReserve.top);					OffsetRect(destReserve, reserveRects[who].left, reserveRects[who].top);					if (not lightsOut) then						if (inColor) then						begin							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(virginCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end						else						begin							CopyBits(offReserveMap, offVirginMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, offLoadMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, mainWndo^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end;				end;			extraIt:		{folded piece of paper}				if (eventKind[who, 1] <> 0) then				begin					DoTheSound(10);					StartScoreRolling;					suppScore := suppScore + eventKind[who, 1];					FloatTheScore(eventKind[who, 1]);					eventKind[who, 1] := 0;					thisHouse.theRooms[roomAt].theObjects[who].amount := 0;					IncInt(mortals);					if (mortals <= 4) then					begin						SetRect(tempRect, 507, 5, 542, 20);						OffsetRect(tempRect, -37 * (mortals - 1), 0);						SetRect(srcR, 0, 318, 35, 333);						if (inColor) then						begin							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(virginCPtr^.portPixMap^)^, srcR, srcR, tempRect);							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, tempRect, tempRect, srcCopy, wholeRgn);							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, tempRect, tempRect, srcCopy, wholeRgn);						end						else						begin							CopyMask(offPlayerMap, offMaskMap, offVirginMap, srcR, srcR, tempRect);							CopyBits(offVirginMap, offLoadMap, tempRect, tempRect, srcCopy, wholeRgn);							CopyBits(offVirginMap, mainWndo^.portBits, tempRect, tempRect, srcCopy, wholeRgn);						end;						if (mortals = 4) then						begin							PenNormal;							SetRect(tempRect, 384, 5, 396, 20);							PaintRect(tempRect);							MoveTo(tempRect.left, tempRect.bottom - 2);							TextFont(16);							TextSize(12);							NumToString(mortals - 1, tempStr);							if (inColor) then							begin								RGBForeColor(rgbRed);								PenMode(srcOr);								DrawString(tempStr);								PenNormal;								RGBForeColor(rgbBlack);								CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, tempRect, tempRect, srcCopy, nil);								CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, tempRect, tempRect, srcCopy, wholeRgn);							end							else							begin								TextMode(patXOr);								DrawString(tempStr);								PenNormal;								CopyBits(offVirginMap, offLoadMap, tempRect, tempRect, srcCopy, nil);								CopyBits(offVirginMap, mainWndo^.portBits, tempRect, tempRect, srcCopy, wholeRgn);							end;						end;					end					else					begin						PenNormal;						SetRect(tempRect, 384, 5, 396, 20);						PaintRect(tempRect);						MoveTo(tempRect.left, tempRect.bottom - 2);						TextFont(16);						TextSize(12);						NumToString(mortals - 1, tempStr);						if (inColor) then						begin							RGBForeColor(rgbRed);							PenMode(srcOr);							DrawString(tempStr);							PenNormal;							RGBForeColor(rgbBlack);							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, tempRect, tempRect, srcCopy, nil);							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, tempRect, tempRect, srcCopy, wholeRgn);						end						else						begin							TextMode(patXOr);							DrawString(tempStr);							PenNormal;							CopyBits(offVirginMap, offLoadMap, tempRect, tempRect, srcCopy, nil);							CopyBits(offVirginMap, mainWndo^.portBits, tempRect, tempRect, srcCopy, wholeRgn);						end;					end;					destReserve := eventRect[who];					OffsetRect(destReserve, -destReserve.left, -destReserve.top);					OffsetRect(destReserve, reserveRects[who].left, reserveRects[who].top);					if (not lightsOut) then						if (inColor) then						begin							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(virginCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end						else						begin							CopyBits(offReserveMap, offVirginMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, offLoadMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, mainWndo^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end;				end;			spillIt: 		{grease upright}			begin				eventRect[who].left := eventRect[who].right;				eventRect[who].right := eventRect[who].right;				eventRect[who].top := eventRect[who].bottom - 5;				eventKind[who, 0] := ignoreIt;	{signal to the cycleOb loop that a spill has occurred}				thisHouse.theRooms[roomAt].theObjects[who].isOn := FALSE;			end;			slideIt: 		{grease spilt}			begin				with theGlider do				begin					tempInt := eventRect[who].top - touchRect.bottom + 1;					destRect.top := destRect.top + tempInt;					destRect.bottom := destRect.bottom + tempInt;					touchRect.top := touchRect.top + tempInt;					touchRect.bottom := touchRect.bottom + tempInt;				end;				sliding := TRUE;			end;			bandIt: 			{rubber bands}				if (eventKind[who, 1] <> 0) then				begin					DoTheSound(12);					theGlider.bands := theGlider.bands + eventKind[who, 1];					FloatTheScore(eventKind[who, 1]);					eventKind[who, 1] := 0;					thisHouse.theRooms[roomAt].theObjects[who].amount := 0;					PopTokenBand;					UpdateBandNumbers;					destReserve := eventRect[who];					OffsetRect(destReserve, -destReserve.left, -destReserve.top);					OffsetRect(destReserve, reserveRects[who].left, reserveRects[who].top);					if (not lightsOut) then						if (inColor) then						begin							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(virginCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end						else						begin							CopyBits(offReserveMap, offVirginMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, offLoadMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, mainWndo^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end;				end;			energizeIt: 		{battery}				if (eventKind[who, 1] <> 0) then				begin					DoTheSound(9);					theGlider.energy := theGlider.energy + eventKind[who, 1];					FloatTheScore(eventKind[who, 1]);					eventKind[who, 1] := 0;					thisHouse.theRooms[roomAt].theObjects[who].amount := 0;					PopTokenBattery;					UpdateBatteryEnergy;					destReserve := eventRect[who];					OffsetRect(destReserve, -destReserve.left, -destReserve.top);					OffsetRect(destReserve, reserveRects[who].left, reserveRects[who].top);					if (not lightsOut) then						if (inColor) then						begin							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(virginCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, destReserve, eventRect[who], srcCopy, nil);							CopyBits(BitMapPtr(reserveCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end						else						begin							CopyBits(offReserveMap, offVirginMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, offLoadMap, destReserve, eventRect[who], srcCopy, nil);							CopyBits(offReserveMap, mainWndo^.portBits, destReserve, eventRect[who], srcCopy, wholeRgn);						end;				end;			trickIt: 		{good move!}				if (eventKind[who, 1] <> 0) then				begin					DoTheSound(kWhistleSound);					StartScoreRolling;					suppScore := suppScore + eventKind[who, 1];					FloatTheScore(eventKind[who, 1]);					eventKind[who, 1] := 0;				end;			lightIt: 				if (lightsOut) then				begin					DoTheSound(18);					lightsOut := FALSE;					thisHouse.theRooms[roomAt].conditionCode := 0;					LoadABackground(thisHouse.theRooms[roomAt].backPictID);					ArrangeTiles;					DrawAllObjects;					DrawHeadline;					if (inColor) then					begin						CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, wholeArea, wholeArea, srcCopy, wholeRgn);						CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, wholeRgn);					end					else					begin						CopyBits(offVirginMap, offLoadMap, wholeArea, wholeArea, srcCopy, wholeRgn);						CopyBits(offVirginMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, wholeRgn);					end;				end;			airOnIt: 				if (airOut) then				begin					DoTheSound(3);					airOut := FALSE;				end;			zapIt: 				if (eventKind[who, 1] <> 0) then				begin					lifeNormal := FALSE;					DoTheSound(24);					with theGlider do					begin						mode := fadingOut;						destRect.top := destRect.bottom - 20;						if (isForward) then							srcNum := 0						else							srcNum := 2;					end;				end;			toggleIt: 				if (eventKind[who, 2] < TickCount) then				begin					DoTheSound(18);					tempInt := eventKind[who, 1];					with thisHouse.theRooms[roomAt].theObjects[tempInt] do					begin						isOn := not isOn;						case objectIs of							lftFan: 								if (eventKind[tempInt, 0] = ignoreIt) then								begin									DoTheSound(3);									eventKind[tempInt, 0] := turnItLeft;								end								else									eventKind[tempInt, 0] := ignoreIt;							ritFan: 								if (eventKind[tempInt, 0] = ignoreIt) then								begin									DoTheSound(3);									eventKind[tempInt, 0] := turnItRight;								end								else									eventKind[tempInt, 0] := ignoreIt;							shredr: 								if (eventKind[tempInt, 0] = ignoreIt) then									eventKind[tempInt, 0] := shredIt								else									eventKind[tempInt, 0] := ignoreIt;							otherwise						end;	{case}					end;		{with}					eventKind[who, 2] := TickCount + 90;				end;			playIt: 				if (eventKind[who, 1] < TickCount) then				begin					DoTheSound(15);					eventKind[who, 1] := TickCount + 120;				end;			ascendIt: 			begin				lifeNormal := FALSE;				theGlider.mode := ascending;				UpAFlight(eventKind[who, 1]);				hotRect := nullRect;			{don't die in rest of SearchRects}			end;			descendIt: 			begin				lifeNormal := FALSE;				theGlider.mode := descending;				DownAFlight(eventKind[who, 1]);				hotRect := nullRect;			{don't die in rest of SearchRects}			end;			shredIt: 			begin				lifeNormal := FALSE;				with theGlider do				begin					mode := shredding;					destRect.top := eventRect[who].bottom;					destRect.bottom := destRect.top;					destRect.left := eventRect[who].left + 12;					destRect.right := destRect.left + 48;					shadoDest.left := destRect.left;					shadoDest.right := destRect.right;					phase := 0;				end;			end;			steamIt: 			begin				liftAmount := -7;				shiftAmount := -7;			end;			otherwise		end;	{case}	end;{=================================}	procedure SearchRects;		var			index, outside: Integer;			tempRect: Rect;{----------------}		function RectLap (rect1, rect2: Rect): Boolean;			var				dumRect: Rect;		begin			RectLap := FALSE;			if (rect1.right < rect2.left) then				Exit(RectLap);			if (rect2.right < rect2.left) then				Exit(RectLap);			if (rect1.bottom < rect2.top) then				Exit(RectLap);			if (rect2.bottom < rect2.top) then				Exit(RectLap);			RectLap := SectRect(rect1, rect2, dumRect);		end;{----------------}		procedure BiteIt;		begin			with theGlider do			begin				DoTheSound(1);				lifeNormal := FALSE;				mode := fadingOut;				destRect.top := destRect.bottom - 20;				if (isForward) then					srcNum := 0				else					srcNum := 2;			end;		end;{----------------}		procedure GetItLegal;		begin{do a bump sound here}			with theGlider do			begin				with destRect do				begin					left := left + outside;					right := right + outside;				end;				with shadoDest do				begin					left := left + outside;					right := right + outside;				end;				with touchRect do				begin					left := left + outside;					right := right + outside;				end;			end;		end;{----------------}	begin		with theGlider do		begin			hotRect := touchRect;					{get 'hot rect'}			if (rightIsOpen) then					{check right edge}			begin				if (destRect.left > 500) then				begin					AdvanceARoom;					Exit(SearchRects);				end			end			else if (destRect.right > 512) then			begin				outside := 512 - destRect.right;				GetItLegal;			end;			if (leftIsOpen) then					{check left edge}			begin				if (destRect.right < 12) then				begin					RetreatARoom;					Exit(SearchRects);				end;			end			else if (destRect.left < 0) then			begin				outside := -destRect.left;				GetItLegal;			end;			if (destRect.bottom > kFloorLimit) then	{check floor}				BiteIt;		end;	{---with theGlider do---}		shiftAmount := 0;		for index := 1 to nObjects do			if (RectLap(eventRect[index], hotRect)) then				Collision(eventKind[index, 0], index);		if (nAnimates <> 0) then			for index := 1 to nAnimates do				if (RectLap(theAnimates[index].destRect, hotRect)) then				begin					BiteIt;					Leave;				end;	end;{=================================}	procedure HandleBand;		var			index: Integer;			tempRect: Rect;{----------------}		function RectLap (rect1, rect2: Rect): Boolean;			var				dumRect: Rect;		begin			RectLap := FALSE;			if (rect1.right < rect2.left) then				Exit(RectLap);			if (rect2.right < rect2.left) then				Exit(RectLap);			if (rect1.bottom < rect2.top) then				Exit(RectLap);			if (rect2.bottom < rect2.top) then				Exit(RectLap);			RectLap := SectRect(rect1, rect2, dumRect);		end;{----------------}	begin		with theBand do		begin			if ((whole.left > 512) or (whole.left < -16)) then				bandBorne := FALSE;			IncInt(phase);			if (phase > 2) then				phase := 0;			whole := dest;			with dest do			begin				left := left + velocity;				right := right + velocity;			end;			if (velocity > 0) then				whole.right := whole.right + velocity			else				whole.left := whole.left + velocity;			if (nAnimates > 0) then				for index := 1 to nAnimates do					with theAnimates[index] do						if (vertOff <> 12) then							if (RectLap(destRect, dest)) then							begin								case kind of									0: 										DoTheSound(6);									1: 										DoTheSound(6);									2: 										DoTheSound(19);									otherwise								end;								phase := -1;								StartScoreRolling;								suppScore := suppScore + 100 * (3 - kind);								horiOff := 0;								vertOff := 12;							end;		end;	{with}	end;{=================================}	procedure GetInput;		const			holdKey = 1;			dropKey = 2;			absMouse = 3;			relMouse = 4;		var			pull: Integer;			thePt: Point;			dest: Rect;{--------------------}		procedure PushIt (howFast: Integer);		begin			with theGlider do				if (energy > 0) then				begin					energy := energy - 1;					DoTheSound(26);					UpdateBatteryEnergy;					if (energy = 0) then					begin						SetRect(dest, 308, 5, 335, 20);						FillRect(dest, black);						if (inColor) then						begin							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, dest, dest, srcCopy, wholeRgn);							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, dest, dest, srcCopy, wholeRgn)						end						else						begin							CopyBits(offVirginMap, mainWndo^.portBits, dest, dest, srcCopy, wholeRgn);							CopyBits(offVirginMap, offLoadMap, dest, dest, srcCopy, wholeRgn);						end;					end;					forVel := howFast;				end;		end;{--------------------}		procedure FireBand;		begin			with theGlider do				if (bands > 0) then				begin					DoTheSound(11);					bands := bands - 1;					UpdateBandNumbers;					if (bands = 0) then					begin						SetRect(dest, 346, 5, 368, 20);						FillRect(dest, black);						if (inColor) then						begin							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, dest, dest, srcCopy, wholeRgn);							CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, dest, dest, srcCopy, wholeRgn);						end						else						begin							CopyBits(offVirginMap, mainWndo^.portBits, dest, dest, srcCopy, wholeRgn);							CopyBits(offVirginMap, offLoadMap, dest, dest, srcCopy, wholeRgn);						end;					end;					bandBorne := TRUE;					with theBand do					begin						dest.top := destRect.top + 6;						dest.bottom := dest.top + 7;						if (isRight) then						begin							dest.left := destRect.right;							velocity := 16;						end						else						begin							dest.left := destRect.left - 16;							velocity := -16;						end;						dest.right := dest.left + 16;						whole := dest;						old := dest;					end;				end;		end;{--------------------}	begin		with theGlider do		begin			case controlMethod of				holdKey: 				begin					if (theKeys[leftKey]) then						if (isRight) then						begin							isForward := FALSE;							srcNum := 1;							forVel := -kMaxThrust;						end						else						begin							isForward := TRUE;							srcNum := 2;							forVel := -kMaxThrust;						end					else if (theKeys[rightKey]) then						if (isRight) then						begin							isForward := TRUE;							srcNum := 0;							forVel := kMaxThrust;						end						else						begin							isForward := FALSE;							srcNum := 3;							forVel := kMaxThrust;						end					else	{no key of import down}					begin						if (isRight) then						begin							isForward := TRUE;							srcNum := 0;							forVel := 0;						end						else						begin							isForward := TRUE;							srcNum := 2;							forVel := 0;						end;					end;					if (theKeys[bandKey] and (not bandBorne)) then		{fire rubber bands}						FireBand;					if (theKeys[energyKey]) then					begin						if (((isRight) and (isForward)) or ((not isRight) and (not isForward))) then							PushIt(16)						else							PushIt(-16);					end;				end;				dropKey: 				begin					if (((isRight) and (isForward)) or ((not isRight) and (not isForward))) then						forVel := kMaxThrust					else						forVel := -kMaxThrust;					if (theKeys[leftKey]) then						if (isRight) then						begin							isForward := FALSE;							srcNum := 1;							forVel := -kMaxThrust;						end						else						begin							isForward := TRUE;							srcNum := 2;							forVel := -kMaxThrust;						end					else if (theKeys[rightKey]) then						if (isRight) then						begin							isForward := TRUE;							srcNum := 0;							forVel := kMaxThrust;						end						else						begin							isForward := FALSE;							srcNum := 3;							forVel := kMaxThrust;						end;					if (theKeys[bandKey] and (not bandBorne)) then		{fire rubber bands}						FireBand;					if (theKeys[energyKey]) then					begin						if (((isRight) and (isForward)) or ((not isRight) and (not isForward))) then							PushIt(16)						else							PushIt(-16);					end;				end;	{end - dropKey}				absMouse: 				begin					if ((theKeys[bandKey]) and (not bandBorne)) then						FireBand;					GetMouse(thePt);					HorizonMouse;					pull := (thePt.h - 256) div 32;					if (pull > kMaxThrust) then						pull := kMaxThrust					else if (pull < -kMaxThrust) then						pull := -kMaxThrust;					forVel := pull;					if (isRight) then						if (forVel < 0) then						begin							isForward := FALSE;							srcNum := 1;							if (theKeys[energyKey]) then								PushIt(-16);							if (button) then							begin								if (not buttonFires) then									PushIt(-16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end						else						begin							isForward := TRUE;							srcNum := 0;							if (theKeys[energyKey]) then								PushIt(16);							if (button) then							begin								if (not buttonFires) then									PushIt(16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end					else					begin						if (forVel < 0) then						begin							isForward := TRUE;							srcNum := 2;							if (theKeys[energyKey]) then								PushIt(-16);							if (button) then							begin								if (not buttonFires) then									PushIt(-16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end						else						begin							isForward := FALSE;							srcNum := 3;							if (theKeys[energyKey]) then								PushIt(16);							if (button) then							begin								if (not buttonFires) then									PushIt(16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end;					end;				end;		{end - absMouse}				relMouse: 				begin					if (theKeys[bandKey] and (not bandBorne)) then		{fire rubber bands}						FireBand;					GetMouse(thePt);					forVel := (thePt.h - 256);					if (forVel > kMaxThrust) then						forVel := kMaxThrust					else if (forVel < -kMaxThrust) then						forVel := -kMaxThrust;					CenterMouse;					if (isRight) then						if (forVel < 0) then						begin							isForward := FALSE;							srcNum := 1;							if (theKeys[energyKey]) then								PushIt(-16);							if (button) then							begin								if (not buttonFires) then									PushIt(-16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end						else						begin							isForward := TRUE;							srcNum := 0;							if (theKeys[energyKey]) then								PushIt(16);							if (button) then							begin								if (not buttonFires) then									PushIt(16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end					else					begin						if (forVel < 0) then						begin							isForward := TRUE;							srcNum := 2;							if (theKeys[energyKey]) then								PushIt(-16);							if (button) then							begin								if (not buttonFires) then									PushIt(-16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end						else						begin							isForward := FALSE;							srcNum := 3;							if (theKeys[energyKey]) then								PushIt(16);							if (button) then							begin								if (not buttonFires) then									PushIt(16)								else if ((not bandBorne) and (buttonFires)) then									FireBand;							end;						end;					end;				end;		{end - relMouse}				otherwise			end;		{case}		end;	{with theGlider}	end;{=================================}	procedure MoveGlider;	begin		if (windowOpen) then			{randomly move glider}		begin			liftAmount := liftAmount + Randomize(11) - 5;			shiftAmount := shiftAmount + Randomize(11) - 5;		end;		with theGlider do		begin			liftAmount := liftAmount + 1;	{add gravity}			if (sliding) then			begin				liftAmount := 0;				{zero out lift}				sliding := FALSE;			end			else			begin						{vertical offset of glider}				destRect.top := destRect.top + liftAmount;				destRect.bottom := destRect.bottom + liftAmount;				touchRect.top := touchRect.top + liftAmount;				touchRect.bottom := touchRect.bottom + liftAmount;			end;			forVel := forVel + shiftAmount;	{horizontal offset of glider}			destRect.left := destRect.left + forVel;			destRect.right := destRect.right + forVel;			touchRect.left := destRect.left + 10;		{touch rect is inset from dest}			touchRect.right := destRect.right - 10;			shadoDest.left := destRect.left;			{shadow has same l. & r. as dest}			shadoDest.right := destRect.right;		end;	end;{=================================}	procedure MoveAnimates;		var			index: Integer;			tempRect: Rect;{----------------}		function RectLap (rect1, rect2: Rect): Boolean;			var				dumRect: Rect;		begin			RectLap := FALSE;			if (rect1.right < rect2.left) then				Exit(RectLap);			if (rect2.right < rect2.left) then				Exit(RectLap);			if (rect1.bottom < rect2.top) then				Exit(RectLap);			if (rect2.bottom < rect2.top) then				Exit(RectLap);			RectLap := SectRect(rect1, rect2, dumRect);		end;{----------------}	begin		for index := 1 to nAnimates do			with theAnimates[index] do			begin				if (unSeen) then				begin					if (TickCount > tickStamp) then					begin						ResetAnimate(-1, index);						unSeen := FALSE;					end;				end				else				begin					if (phase > -1) then					begin						IncInt(phase);						if (phase > 7) then							phase := 0;					end;					wholeRect := destRect;					with destRect do					begin						case kind of							0: 							begin								left := left + horiOff;								right := right + horiOff;								top := top + vertOff;								bottom := bottom + vertOff;								wholeRect.left := wholeRect.left + horiOff;								wholeRect.bottom := wholeRect.bottom + vertOff;							end;							1: 							begin								left := left + horiOff;								right := right + horiOff;								top := top + vertOff;								bottom := bottom + vertOff;								wholeRect.left := wholeRect.left + horiOff;								wholeRect.bottom := wholeRect.bottom + vertOff;							end;							2: 							begin								top := top + vertOff;								bottom := bottom + vertOff;								if (vertOff > 0) then									wholeRect.bottom := wholeRect.bottom + vertOff								else									wholeRect.top := wholeRect.top + vertOff;							end;							otherwise						end;	{case kind of}					end;		{with destRect}					if (not unseen) then						if (not RectLap(wholeRect, wholeArea)) then						begin							tickStamp := TickCount + delay;							destRect := nullRect;							wholeRect := nullRect;							unSeen := TRUE;						end;				end;	{if NOT (unSeen)}			end;	{with / for}	end;{=================================}	procedure MoveCycleObs;		var			index, diff: Integer;	begin		for index := 1 to nCycleObs do			with cycleObjects[index] do				case kindIs of					candle: 					begin						IncLong(position);						if (position > 50) then							position := 48;					end;					grease: 					begin						if (eventKind[tiedTo, 0] = ignoreIt) then						begin							DoTheSound(14);							eventKind[tiedTo, 0] := slideIt;							reset := 1;						end						else if ((reset <> 0) and (reset <> 999)) then						begin							reset := reset + 1;							if (reset > 4) then							begin								velocity := velocity + 1;								eventRect[tiedTo].right := eventRect[tiedTo].right + 1;								if (velocity > position) then									reset := 999;							end							else							begin								if (reset < 3) then									accel := 58								else									accel := 59;							end;						end;					end;					outlet: 					begin						if (accel = 25) then						begin							if (TickCount > position) then							begin								accel := binaryFlip + 51;	{go into zap mode}								position := TickCount;								eventKind[tiedTo, 1] := 1;							end;						end						else						begin							if (TickCount > (position + 60)) then							begin								accel := 25;				{stop zapping}								position := TickCount + reset;								eventKind[tiedTo, 1] := 0;							end							else							begin								DoTheSound(24);			{zapping}								accel := binaryFlip + 51;							end;						end;					end;					drip: 					begin						if (phase < 57) then						begin							if (binaryFlip <> 0) then							begin								IncInt(phase);								if (phase = 57) then									position := position + 160;							end;						end						else						begin							velocity := velocity + accel;							position := position + velocity;							if (position > reset) then							begin								DoTheSound(7);								velocity := 0;								position := holdRect.bottom * 32;								if (inColor) then								begin									CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, eventRect[tiedTo], eventRect[tiedTo], srcCopy, wholeRgn);									CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, eventRect[tiedTo], eventRect[tiedTo], srcCopy, wholeRgn);								end								else								begin									CopyBits(offVirginMap, offLoadMap, eventRect[tiedTo], eventRect[tiedTo], srcCopy, wholeRgn);									CopyBits(offVirginMap, mainWndo^.portBits, eventRect[tiedTo], eventRect[tiedTo], srcCopy, wholeRgn);								end;								eventRect[tiedTo] := holdRect;								phase := 53;							end;							wholeRect := eventRect[tiedTo];							with eventRect[tiedTo] do							begin								diff := LoWord(BSR(position, 5)) - bottom;								bottom := bottom + diff;								top := top + diff;							end;							wholeRect.bottom := wholeRect.bottom + diff						end;	{else }					end;	{drip}					toastr: 						if (phase <> 0) then						begin							if (binaryFlip = 0) then							begin								phase := phase + 1;								if (phase > 65) then									phase := 60;							end;							velocity := velocity + accel;							position := position + velocity;							if (position > reset) then							begin								DoTheSound(22);								velocity := -velocity;								position := reset;								reset := TickCount + thisHouse.theRooms[roomAt].theObjects[tiedTo].extra;								phase := 0;							end;							wholeRect := eventRect[tiedTo];							with eventRect[tiedTo] do							begin								diff := LoWord(BSR(position, 5)) - bottom;								bottom := bottom + diff;								top := top + diff;							end;							if (diff > 0) then								wholeRect.bottom := wholeRect.bottom + diff							else								wholeRect.top := wholeRect.top + diff;						end						else						begin							if (TickCount > reset) then							begin								DoTheSound(23);								reset := position;								phase := 60;							end;						end;	{toastr}					ball: 					begin						velocity := velocity + accel;						position := position + velocity;						if (position > reset) then						begin							DoTheSound(4);							velocity := -velocity;							position := reset;						end;						wholeRect := eventRect[tiedTo];						with eventRect[tiedTo] do						begin							diff := LoWord(BSR(position, 5)) - bottom;							bottom := bottom + diff;							top := top + diff;						end;						if (diff > 0) then							wholeRect.bottom := wholeRect.bottom + diff						else							wholeRect.top := wholeRect.top + diff;					end;	{ball}					fshBwl: 						if (phase <> 0) then						begin							if ((velocity > -16) and (velocity < 16)) then								phase := 69							else							begin								if (velocity < 0) then									phase := 66								else									phase := 68;							end;							velocity := velocity + accel;							position := position + velocity;							if (position > reset) then							begin								DoTheSound(7);								velocity := -velocity;								position := reset;								reset := TickCount + thisHouse.theRooms[roomAt].theObjects[tiedTo].extra;								phase := 0;							end;							wholeRect := eventRect[tiedTo];							with eventRect[tiedTo] do							begin								diff := LoWord(BSR(position, 5)) - bottom;								bottom := bottom + diff;								top := top + diff;							end;							if (diff > 0) then								wholeRect.bottom := wholeRect.bottom + diff							else								wholeRect.top := wholeRect.top + diff;						end						else						begin							if (TickCount > reset) then							begin								DoTheSound(7);								reset := position;								phase := 66;							end;						end;	{fish bowl}					teaKtl: 					begin						if (TickCount > reset) then						begin							eventKind[tiedTo, 0] := steamIt;							if (phase = 0) then								DoTheSound(25);							phase := phase + 1;							if (phase > 10) then							begin								phase := 0;								eventKind[tiedTo, 0] := ignoreIt;								reset := TickCount + position;							end;						end;					end;					otherwise				end;	{case / with / index}	end;{=================================}	procedure MonitorStorm;	begin		with theLightning do		begin			if (whatPhase = 0) then			begin				if (TickCount > whatTime) then					whatPhase := 1;			end			else if (whatPhase > 3) then			begin				whatPhase := 0;				whichBolt := Randomize(3) + 1;				whatTime := TickCount + Randomize(300);				DoTheSound(17);			end			else				whatPhase := whatPhase + 1;		end;	end;{=================================}	procedure DrawFlipScene;		var			index, tempInt: Integer;			tempRect, tempSmRect: Rect;	begin		if (mainScreenHidden) then		begin			if (hasWindow) then				if (theLightning.whatPhase <> 0) then					with theLightning do					begin						if (whatPhase = 4) then						begin							SetPort(mainWndo);							SetClip(windowRgn);							PenNormal;							FillRgn(windowRgn, black);							ClipRect(wholeArea);							SetPort(offLoadPort);							SetClip(windowRgn);							FillRgn(windowRgn, black);							ClipRect(wholeArea);							SetPort(offVirginPort);						end						else						begin							SetPort(mainWndo);							SetClip(windowRgn);							PenNormal;							PenSize(2, 2);							PenMode(patXOr);							MoveTo(theBolts[whichBolt, 0, 0], theBolts[whichBolt, 0, 1]);							for index := 1 to 7 do							begin								LineTo(theBolts[whichBolt, index, 0], theBolts[whichBolt, index, 1]);								Move(0, 2);							end;							ClipRect(wholeArea);							SetPort(offVirginPort);						end;					end;{-----pop masks on-----}			if (hasMirror) then				with theGlider do				begin					tempSmRect := destRect;					tempSmRect.left := tempSmRect.left - 16;					tempSmRect.right := tempSmRect.right - 16;					tempSmRect.top := tempSmRect.top - 32;					tempSmRect.bottom := tempSmRect.bottom - 32;					SetPort(mainWndo);					SetClip(mirrorRgn);					CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, glideRct[srcNum], glideRct[srcNum], tempSmRect);					ClipRect(wholeArea);					SetPort(offVirginPort);				end;			if (nCycleObs > 0) then				for index := 1 to nCycleObs do					with cycleObjects[index] do					begin						case kindIs of							candle: 								CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[position], srcRect[position], wholeRect);							outlet: 								CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[accel], srcRect[accel], wholeRect);							grease: 							begin								CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[accel], srcRect[accel], wholeRect);								SetPort(offLoadPort);								PenNormal;								PenSize(2, 2);								MoveTo(velocity - 2, wholeRect.bottom - 2);								if (velocity > wholeRect.right + 1) then									Line(2, 0);								PenNormal;								SetPort(offVirginPort);								PenNormal;								PenSize(2, 2);								MoveTo(velocity - 2, wholeRect.bottom - 2);								if (velocity > wholeRect.right + 1) then									Line(2, 0);								PenNormal;							end;							ball: 								CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[kindIs], srcRect[kindIs], eventRect[tiedTo]);							drip: 								CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[phase], srcRect[phase], eventRect[tiedTo]);							toastr: 								if (phase <> 0) then								begin									SetPort(mainWndo);									SetClip(toastRgn);									CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[phase], srcRect[phase], eventRect[tiedTo]);									ClipRect(wholeArea);									SetPort(offVirginPort);								end;							fshBwl: 								if (phase <> 0) then									CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[phase], srcRect[phase], eventRect[tiedTo])								else									CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, srcRect[69], srcRect[69], eventRect[tiedTo]);							otherwise						end;	{case}					end;			with theGlider do			begin				if (isRight) then					CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, shadoRct[0], shadoRct[0], shadoDest)				else					CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, shadoRct[1], shadoRct[1], shadoDest);				if (lifeNormal) then					CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, glideRct[srcNum], glideRct[srcNum], destRect)				else					case mode of						fadingIn, fadingOut: 						begin							tempInt := nextPhase[mode, phase];							if (not isRight) then								tempInt := tempInt + 7;							CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, glideRct[srcNum], glideRct[tempInt], destRect);						end;						turnLf2Rt, turnRt2Lf: 						begin							tempInt := nextPhase[mode, phase];							CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, glideRct[tempInt], glideRct[tempInt], destRect);						end;						burning, ascending, descending: 							CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, glideRct[srcNum], glideRct[srcNum], destRect);						shredding: 						begin							SetRect(tempRect, 256, 208 - (destRect.bottom - destRect.top), 304, 208);							CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, tempRect, tempRect, destRect);						end;						otherwise					end;	{case}			end;			if (nAnimates > 0) then				for index := 1 to nAnimates do					with theAnimates[index] do						CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, animateRct[kind, phase], animateRct[kind, phase], destRect);			if (bandBorne) then				with theBand do					CopyMask(offPlayerMap, offMaskMap, mainWndo^.portBits, bandRct[phase], bandRct[phase], dest);			with (floatPoints) do				if ((out) and (tickCount > tickStamp)) then				begin					out := FALSE;					CopyBits(offVirginMap, offLoadMap, whereR, whereR, srcCopy, wholeRgn);					CopyBits(offVirginMap, mainWndo^.portBits, whereR, whereR, srcCopy, wholeRgn);				end;{-----flip to 'other' page-----}			mainScreenHidden := not mainScreenHidden;			SetPage(mainScreenHidden);{-----restore 'other' page-----}			if (hasMirror) then				with theGlider do				begin					tempSmRect := oldRect;					tempSmRect.left := tempSmRect.left - 16;					tempSmRect.right := tempSmRect.right - 16;					tempSmRect.top := tempSmRect.top - 32;					tempSmRect.bottom := tempSmRect.bottom - 32;					CopyBits(offVirginMap, offLoadMap, tempSmRect, tempSmRect, srcCopy, wholeRgn);				end;			with theGlider do			begin				CopyBits(offVirginMap, offLoadMap, oldRect, oldRect, srcCopy, wholeRgn);				CopyBits(offVirginMap, offLoadMap, oldShado, oldShado, srcCopy, wholeRgn);				oldRect := destRect;				oldShado := shadoDest;			end;			if (nAnimates > 0) then				for index := 1 to nAnimates do					with theAnimates[index] do					begin						CopyBits(offVirginMap, offLoadMap, oldRect, oldRect, srcCopy, nil);						oldRect := destRect;					end;			if (nCycleObs > 0) then				for index := 1 to nCycleObs do					with cycleObjects[index] do					begin						CopyBits(offVirginMap, offLoadMap, oldRect, oldRect, srcCopy, nil);						oldRect := wholeRect;					end;			if (bandBorne) then				with theBand do				begin					CopyBits(offVirginMap, offLoadMap, old, old, srcCopy, nil);					old := dest;				end;		end		else		{main screen is NOT hidden (is visible)}		begin			if (hasWindow) then				if (theLightning.whatPhase <> 0) then					with theLightning do					begin						if (whatPhase = 4) then						begin							SetPort(mainWndo);							SetClip(windowRgn);							PenNormal;							FillRgn(windowRgn, black);							ClipRect(wholeArea);							SetPort(offLoadPort);							SetClip(windowRgn);							FillRgn(windowRgn, black);							ClipRect(wholeArea);							SetPort(offVirginPort);						end						else						begin							SetPort(offLoadPort);							SetClip(windowRgn);							PenNormal;							PenSize(2, 2);							PenMode(patXOr);							MoveTo(theBolts[whichBolt, 0, 0], theBolts[whichBolt, 0, 1]);							for index := 1 to 7 do							begin								LineTo(theBolts[whichBolt, index, 0], theBolts[whichBolt, index, 1]);								Move(0, 2);							end;							ClipRect(wholeArea);							SetPort(offVirginPort);						end;					end;{-----pop masks on-----}			if (hasMirror) then				with theGlider do				begin					tempSmRect := destRect;					tempSmRect.left := tempSmRect.left - 16;					tempSmRect.right := tempSmRect.right - 16;					tempSmRect.top := tempSmRect.top - 32;					tempSmRect.bottom := tempSmRect.bottom - 32;					SetPort(offLoadPort);					SetClip(mirrorRgn);					CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[srcNum], tempSmRect);					ClipRect(wholeArea);					SetPort(offVirginPort);				end;			if (nCycleObs > 0) then				for index := 1 to nCycleObs do					with cycleObjects[index] do					begin						case kindIs of							candle: 								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[position], srcRect[position], wholeRect);							outlet: 								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[accel], srcRect[accel], wholeRect);							grease: 							begin								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[accel], srcRect[accel], wholeRect);								SetPort(mainWndo);								PenNormal;								PenSize(2, 2);								MoveTo(velocity - 2, wholeRect.bottom - 2);								if (velocity > wholeRect.right + 1) then									Line(2, 0);								PenNormal;								SetPort(offVirginPort);								PenNormal;								PenSize(2, 2);								MoveTo(velocity - 2, wholeRect.bottom - 2);								if (velocity > wholeRect.right + 1) then									Line(2, 0);								PenNormal;							end;							ball: 								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[kindIs], srcRect[kindIs], eventRect[tiedTo]);							drip: 								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[phase], srcRect[phase], eventRect[tiedTo]);							toastr: 								if (phase <> 0) then								begin									SetPort(offLoadPort);									SetClip(toastRgn);									CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[phase], srcRect[phase], eventRect[tiedTo]);									ClipRect(wholeArea);									SetPort(offVirginPort);								end;							fshBwl: 								if (phase <> 0) then									CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[phase], srcRect[phase], eventRect[tiedTo])								else									CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[69], srcRect[69], eventRect[tiedTo]);							otherwise						end;	{case}					end;			with theGlider do			begin				if (isRight) then					CopyMask(offPlayerMap, offMaskMap, offLoadMap, shadoRct[0], shadoRct[0], shadoDest)				else					CopyMask(offPlayerMap, offMaskMap, offLoadMap, shadoRct[1], shadoRct[1], shadoDest);				if (lifeNormal) then					CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[srcNum], destRect)				else					case mode of						fadingIn, fadingOut: 						begin							tempInt := nextPhase[mode, phase];							if (not isRight) then								tempInt := tempInt + 7;							CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[tempInt], destRect);						end;						turnLf2Rt, turnRt2Lf: 						begin							tempInt := nextPhase[mode, phase];							CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[tempInt], glideRct[tempInt], destRect);						end;						burning, ascending, descending: 							CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[srcNum], destRect);						shredding: 						begin							SetRect(tempRect, 256, 208 - (destRect.bottom - destRect.top), 304, 208);							CopyMask(offPlayerMap, offMaskMap, offLoadMap, tempRect, tempRect, destRect);						end;						otherwise					end;	{case}			end;			if (nAnimates > 0) then				for index := 1 to nAnimates do					with theAnimates[index] do						CopyMask(offPlayerMap, offMaskMap, offLoadMap, animateRct[kind, phase], animateRct[kind, phase], destRect);			if (bandBorne) then				with theBand do					CopyMask(offPlayerMap, offMaskMap, offLoadMap, bandRct[phase], bandRct[phase], dest);			with (floatPoints) do				if ((out) and (tickCount > tickStamp)) then				begin					out := FALSE;					CopyBits(offVirginMap, offLoadMap, whereR, whereR, srcCopy, wholeRgn);					CopyBits(offVirginMap, mainWndo^.portBits, whereR, whereR, srcCopy, wholeRgn);				end;{-----flip to 'other' page-----}			mainScreenHidden := not mainScreenHidden;			SetPage(mainScreenHidden);{-----restore 'other' page-----}			if (hasMirror) then				with theGlider do				begin					tempSmRect := oldRect;					tempSmRect.left := tempSmRect.left - 16;					tempSmRect.right := tempSmRect.right - 16;					tempSmRect.top := tempSmRect.top - 32;					tempSmRect.bottom := tempSmRect.bottom - 32;					CopyBits(offVirginMap, mainWndo^.portBits, tempSmRect, tempSmRect, srcCopy, wholeRgn);				end;			with theGlider do			begin				CopyBits(offVirginMap, mainWndo^.portBits, oldRect, oldRect, srcCopy, wholeRgn);				CopyBits(offVirginMap, mainWndo^.portBits, oldShado, oldShado, srcCopy, wholeRgn);				oldRect := destRect;				oldShado := shadoDest;			end;			if (nAnimates > 0) then				for index := 1 to nAnimates do					with theAnimates[index] do					begin						CopyBits(offVirginMap, mainWndo^.portBits, oldRect, oldRect, srcCopy, nil);						oldRect := destRect;					end;			if (nCycleObs > 0) then				for index := 1 to nCycleObs do					with cycleObjects[index] do					begin						CopyBits(offVirginMap, mainWndo^.portBits, oldRect, oldRect, srcCopy, nil);						oldRect := wholeRect;					end;			if (bandBorne) then				with theBand do				begin					CopyBits(offVirginMap, mainWndo^.portBits, old, old, srcCopy, nil);					old := dest;				end;		end;	end;{=================================}	procedure DrawScene;		var			index, tempInt: Integer;			tempRect, tempSmRect: Rect;	begin		if (hasWindow) then			if (theLightning.whatPhase <> 0) then				with theLightning do				begin					SetPort(mainWndo);					SetClip(windowRgn);					PenNormal;					if (whatPhase = 4) then						FillRgn(windowRgn, black)					else					begin						PenSize(2, 2);						PenMode(patXOr);						MoveTo(theBolts[whichBolt, 0, 0], theBolts[whichBolt, 0, 1]);						for index := 1 to 7 do						begin							LineTo(theBolts[whichBolt, index, 0], theBolts[whichBolt, index, 1]);							Move(0, 2);						end;					end;					ClipRect(wholeArea);					SetPort(offVirginPort);				end;		if (hasMirror) then		begin			tempRect := theGlider.oldRect;			tempRect.left := tempRect.left - 16;			tempRect.right := tempRect.right - 16;			tempRect.top := tempRect.top - 32;			tempRect.bottom := tempRect.bottom - 32;			CopyBits(offVirginMap, offLoadMap, tempRect, tempRect, srcCopy, mirrorRgn);		end;		with theGlider do		begin			UnionRect(destRect, oldRect, wholeRect);			UnionRect(shadoDest, oldShado, wholeShado);			CopyBits(offVirginMap, offLoadMap, oldRect, oldRect, srcCopy, wholeRgn);			CopyBits(offVirginMap, offLoadMap, oldShado, oldShado, srcCopy, wholeRgn);			oldRect := destRect;			oldShado := shadoDest;		end;		if (nAnimates > 0) then			for index := 1 to nAnimates do				with theAnimates[index] do					CopyBits(offVirginMap, offLoadMap, oldRect, oldRect, srcCopy, nil);		if (nCycleObs > 0) then			for index := 1 to nCycleObs do				with cycleObjects[index] do					CopyBits(offVirginMap, offLoadMap, oldRect, oldRect, srcCopy, nil);		if (bandBorne) then			with theBand do				CopyBits(offVirginMap, offLoadMap, old, old, srcCopy, nil);{-----pop masks on-----}		if (hasMirror) then			with theGlider do			begin				tempSmRect := destRect;				tempSmRect.left := tempSmRect.left - 16;				tempSmRect.right := tempSmRect.right - 16;				tempSmRect.top := tempSmRect.top - 32;				tempSmRect.bottom := tempSmRect.bottom - 32;				SetPort(offLoadPort);				SetClip(mirrorRgn);				CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[srcNum], tempSmRect);				ClipRect(wholeArea);				SetPort(offVirginPort);				UnionRect(tempRect, tempSmRect, tempRect);			end;		if (nCycleObs > 0) then			for index := 1 to nCycleObs do				with cycleObjects[index] do				begin					case kindIs of						candle: 							CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[position], srcRect[position], wholeRect);						outlet, grease: 							CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[accel], srcRect[accel], wholeRect);						ball: 							CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[kindIs], srcRect[kindIs], eventRect[tiedTo]);						drip: 							CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[phase], srcRect[phase], eventRect[tiedTo]);						toastr: 							if (phase <> 0) then							begin								SetPort(offLoadPort);								SetClip(toastRgn);								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[phase], srcRect[phase], eventRect[tiedTo]);								ClipRect(wholeArea);								SetPort(offVirginPort);							end;						fshBwl: 							if (phase <> 0) then								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[phase], srcRect[phase], eventRect[tiedTo])							else								CopyMask(offPlayerMap, offMaskMap, offLoadMap, srcRect[69], srcRect[69], eventRect[tiedTo]);						otherwise					end;	{case}					oldRect := wholeRect;				end;		with theGlider do		begin			if (isRight) then				CopyMask(offPlayerMap, offMaskMap, offLoadMap, shadoRct[0], shadoRct[0], shadoDest)			else				CopyMask(offPlayerMap, offMaskMap, offLoadMap, shadoRct[1], shadoRct[1], shadoDest);			if (lifeNormal) then				CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[srcNum], destRect)			else				case mode of					fadingIn, fadingOut: 					begin						tempInt := nextPhase[mode, phase];						if (not isRight) then							tempInt := tempInt + 7;						CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[tempInt], destRect);					end;					turnLf2Rt, turnRt2Lf: 					begin						tempInt := nextPhase[mode, phase];						CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[tempInt], glideRct[tempInt], destRect);					end;					burning, ascending, descending: 						CopyMask(offPlayerMap, offMaskMap, offLoadMap, glideRct[srcNum], glideRct[srcNum], destRect);					shredding: 					begin						SetRect(tempRect, 256, 208 - (destRect.bottom - destRect.top), 304, 208);						CopyMask(offPlayerMap, offMaskMap, offLoadMap, tempRect, tempRect, destRect);					end;					otherwise				end;	{case}		end;		if (nAnimates > 0) then			for index := 1 to nAnimates do				with theAnimates[index] do				begin					CopyMask(offPlayerMap, offMaskMap, offLoadMap, animateRct[kind, phase], animateRct[kind, phase], destRect);					oldRect := wholeRect;				end;		if (bandBorne) then			with theBand do			begin				CopyMask(offPlayerMap, offMaskMap, offLoadMap, bandRct[phase], bandRct[phase], dest);				old := dest;			end;{-----pop to visible screen-----}		with (floatPoints) do			if ((out) and (tickCount > tickStamp)) then			begin				out := FALSE;				CopyBits(offVirginMap, mainWndo^.portBits, whereR, whereR, srcCopy, wholeRgn);			end;		if (hasMirror) then			CopyBits(offLoadMap, mainWndo^.portBits, tempRect, tempRect, srcCopy, mirrorRgn);		if (nCycleObs > 0) then			for index := 1 to nCycleObs do				with cycleObjects[index] do				begin					if (kindIs <> grease) then						CopyBits(offLoadMap, mainWndo^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn)					else					begin						CopyBits(offLoadMap, mainWndo^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn);						SetPort(mainWndo);						PenNormal;						PenSize(2, 2);						MoveTo(wholeRect.right, wholeRect.bottom - 2);						if (velocity > wholeRect.right + 1) then							LineTo(velocity, wholeRect.bottom - 2);						PenNormal;						SetPort(offVirginPort);						PenNormal;						PenSize(2, 2);						MoveTo(wholeRect.right, wholeRect.bottom - 2);						if (velocity > wholeRect.right + 1) then							LineTo(velocity, wholeRect.bottom - 2);						PenNormal;					end;				end;		with theGlider do		begin			CopyBits(offLoadMap, mainWndo^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn);			CopyBits(offLoadMap, mainWndo^.portBits, wholeShado, wholeShado, srcCopy, wholeRgn);		end;		if (nAnimates > 0) then			for index := 1 to nAnimates do				with theAnimates[index] do					CopyBits(offLoadMap, mainWndo^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn);		if (bandBorne) then			with theBand do				CopyBits(offLoadMap, mainWndo^.portBits, whole, whole, srcCopy, wholeRgn);	end;{=================================}	procedure DrawCScene;		var			index, tempInt: Integer;			tempRect, tempSmRect: Rect;	begin		if ((hasWindow) and (theLightning.whatPhase <> 0)) then			with theLightning do			begin				SetPort(GrafPtr(mainWndo));				SetClip(windowRgn);				PenNormal;				if (whatPhase = 4) then					FillRgn(windowRgn, black)				else				begin					PenMode(srcXOr);					PenSize(2, 2);					MoveTo(theBolts[whichBolt, 0, 0], theBolts[whichBolt, 0, 1]);					for index := 1 to 7 do					begin						LineTo(theBolts[whichBolt, index, 0], theBolts[whichBolt, index, 1]);						Move(0, 2);					end;				end;				ClipRect(wholeArea);				SetPort(GrafPtr(virginCPtr));			end;		if (hasMirror) then		begin			with theGlider do				UnionRect(destRect, oldRect, tempRect);			tempRect.left := tempRect.left - 32;			tempRect.right := tempRect.right - 32;			tempRect.top := tempRect.top - 32;			tempRect.bottom := tempRect.bottom - 32;			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, tempRect, tempRect, srcCopy, mirrorRgn);		end;		with theGlider do		begin			UnionRect(destRect, oldRect, wholeRect);			UnionRect(shadoDest, oldShado, wholeShado);			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, oldRect, oldRect, srcCopy, wholeRgn);			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, oldShado, oldShado, srcCopy, wholeRgn);			oldRect := destRect;			oldShado := shadoDest;		end;		if (nAnimates > 0) then			for index := 1 to nAnimates do				with theAnimates[index] do					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, oldRect, oldRect, srcCopy, wholeRgn);		if (nCycleObs > 0) then			for index := 1 to nCycleObs do				with cycleObjects[index] do					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, oldRect, oldRect, srcCopy, wholeRgn);		if (bandBorne) then			with theBand do				CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, old, old, srcCopy, wholeRgn);{-----pop masks on-----}		if (hasMirror) then			with theGlider do			begin				tempSmRect := destRect;				tempSmRect.left := tempSmRect.left - 32;				tempSmRect.right := tempSmRect.right - 32;				tempSmRect.top := tempSmRect.top - 32;				tempSmRect.bottom := tempSmRect.bottom - 32;				SetPort(GrafPtr(loadCPtr));				SetClip(mirrorRgn);				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, glideRct[srcNum], glideRct[srcNum], tempSmRect);				ClipRect(wholeArea);				SetPort(GrafPtr(virginCPtr));			end;		if (nCycleObs > 0) then			for index := 1 to nCycleObs do				with cycleObjects[index] do				begin					case kindIs of						candle: 							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[position], srcRect[position], wholeRect);						outlet, grease: 							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[accel], srcRect[accel], wholeRect);						ball: 							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[kindIs], srcRect[kindIs], eventRect[tiedTo]);						drip: 							CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[phase], srcRect[phase], eventRect[tiedTo]);						toastr: 							if (phase <> 0) then							begin								SetPort(GrafPtr(loadCPtr));								SetClip(toastRgn);								CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[phase], srcRect[phase], eventRect[tiedTo]);								ClipRect(wholeArea);								SetPort(GrafPtr(virginCPtr));							end;						fshBwl: 						begin							if (phase <> 0) then								CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[phase], srcRect[phase], eventRect[tiedTo])							else								CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, srcRect[69], srcRect[69], eventRect[tiedTo]);						end;						otherwise							;					end;	{case}					oldRect := wholeRect;				end;		with theGlider do		begin			if (isRight) then				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, shadoRct[0], shadoRct[0], shadoDest)			else				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, shadoRct[1], shadoRct[1], shadoDest);			if (lifeNormal) then				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, glideRct[srcNum], glideRct[srcNum], destRect)			else				case mode of					fadingIn, fadingOut: 					begin						tempInt := nextPhase[mode, phase];						if (not isRight) then							tempInt := tempInt + 7;						CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, glideRct[srcNum], glideRct[tempInt], destRect);					end;					turnLf2Rt, turnRt2Lf: 					begin						tempInt := nextPhase[mode, phase];						CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, glideRct[tempInt], glideRct[tempInt], destRect);					end;					burning, ascending, descending: 						CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, glideRct[srcNum], glideRct[srcNum], destRect);					shredding: 					begin						SetRect(tempRect, 256, 208 - (destRect.bottom - destRect.top), 304, 208);						CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, tempRect, tempRect, destRect);					end;					otherwise				end;	{case}		end;		if (nAnimates > 0) then			for index := 1 to nAnimates do				with theAnimates[index] do				begin					CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, animateRct[kind, phase], animateRct[kind, phase], destRect);					oldRect := wholeRect;				end;		if (bandBorne) then			with theBand do			begin				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, bandRct[phase], bandRct[phase], dest);				old := dest;			end;{-----pop to visible screen-----}		with (floatPoints) do			if (out) then			begin				if (tickCount > tickStamp) then				begin					out := FALSE;					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, whereR, whereR, srcCopy, wholeRgn);				end				else				begin					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, whereR, whereR, srcCopy, wholeRgn);					SetPort(GrafPtr(mainWndo));					PenNormal;					whereR.right := whereR.right + 2;					whereR.left := whereR.left + 2;					whereR.top := whereR.top - 1;					whereR.bottom := whereR.bottom - 1;					TextFont(16);					TextSize(12);					MoveTo(whereR.left, whereR.bottom - 2);					if (binaryFlip = 0) then						RGBForeColor(rgbBlue)					else						RGBForeColor(rgbRed);					PenMode(srcOr);					DrawString(saysWhat);					PenNormal;					RGBForeColor(rgbBlack);					SetPort(GrafPtr(virginCPtr))				end;			end;		if (hasMirror) then			CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, tempRect, tempRect, srcCopy, mirrorRgn);		if (nCycleObs > 0) then			for index := 1 to nCycleObs do				with cycleObjects[index] do				begin					if (kindIs <> grease) then						CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn)					else					begin						CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn);						SetPort(GrafPtr(mainWndo));						PenNormal;						PenSize(2, 2);						MoveTo(wholeRect.right, wholeRect.bottom - 2);						if (velocity > wholeRect.right + 1) then							LineTo(velocity, wholeRect.bottom - 2);						PenNormal;						SetPort(GrafPtr(virginCPtr));						PenNormal;						PenSize(2, 2);						MoveTo(wholeRect.right, wholeRect.bottom - 2);						if (velocity > wholeRect.right + 1) then							LineTo(velocity, wholeRect.bottom - 2);						PenNormal;					end;				end;		with theGlider do		begin			CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn);			CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeShado, wholeShado, srcCopy, wholeRgn);		end;		if (nAnimates > 0) then			for index := 1 to nAnimates do				with theAnimates[index] do					CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeRect, wholeRect, srcCopy, wholeRgn);		if (bandBorne) then			with theBand do				CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, whole, whole, srcCopy, wholeRgn);	end;{=================================}	procedure DoSpecial;	begin		GetKeys(theKeys);		with theGlider do			case mode of				fadingIn: 				begin					if (phase = 1) then						DoTheSound(2);					IncInt(phase);					if (phase > 16) then					begin						if (isRight) then							srcNum := 0						else							srcNum := 2;						lifeNormal := TRUE;						phase := 0;						mode := normal;					end				end;				fadingOut: 				begin					IncInt(phase);					if (isRight) then						srcNum := 0					else						srcNum := 2;					if (phase > 16) then						OffAMortal;				end;				turnRt2Lf: 				begin					IncInt(phase);					if (phase > 11) then					begin						lifeNormal := TRUE;						phase := 0;						mode := normal;						shiftAmount := 0;						isRight := FALSE;					end;					SearchRects;					destRect.left := destRect.left + shiftAmount;					destRect.right := destRect.right + shiftAmount;					touchRect.left := touchRect.left + shiftAmount;					touchRect.right := touchRect.right + shiftAmount;					shadoDest.left := shadoDest.left + shiftAmount;					shadoDest.right := shadoDest.right + shiftAmount;				end;				turnLf2Rt: 				begin					IncInt(phase);					if (phase > 11) then					begin						lifeNormal := TRUE;						phase := 0;						mode := normal;						shiftAmount := 0;						isRight := TRUE;					end;					SearchRects;					destRect.left := destRect.left + shiftAmount;					destRect.right := destRect.right + shiftAmount;					touchRect.left := touchRect.left + shiftAmount;					touchRect.right := touchRect.right + shiftAmount;					shadoDest.left := shadoDest.left + shiftAmount;					shadoDest.right := shadoDest.right + shiftAmount;				end;				burning: 				begin					phase := 1 - phase;					if (isRight) then					begin						srcNum := 24 + phase;						forVel := 1;					end					else					begin						srcNum := 26 + phase;						forVel := -1;					end;					SearchRects;					MoveGlider;					if (TickCount > timeStamp) then					begin						DoTheSound(1);						mode := fadingOut;						phase := 0;						destRect.top := destRect.bottom - 20;						if (isForward) then							srcNum := 0						else							srcNum := 2;					end;				end;				ascending: 				begin					destRect.left := destRect.left - 2;					destRect.right := destRect.left + 48;					destRect.top := destRect.top - 6;					destRect.bottom := destRect.top + 20;					shadoDest.left := destRect.left;					shadoDest.right := destRect.right;					touchRect := destRect;					InsetRect(touchRect, 10, 5);					if (destRect.top < 220) then					begin						lifeNormal := TRUE;						phase := 0;						mode := normal;					end;				end;				descending: 				begin					destRect.left := destRect.left + 2;					destRect.right := destRect.left + 48;					destRect.top := destRect.top + 6;					destRect.bottom := destRect.top + 20;					shadoDest.left := destRect.left;					shadoDest.right := destRect.right;					touchRect := destRect;					InsetRect(touchRect, 10, 5);					if (destRect.top > 120) then					begin						lifeNormal := TRUE;						phase := 0;						mode := normal;					end;				end;				shredding: 				begin					if (phase = 0) then					begin						DoTheSound(20);						destRect.bottom := destRect.bottom + 1;						if (destRect.bottom >= destRect.top + 36) then							phase := 1;					end					else					begin						destRect.top := destRect.top + 8;						destRect.bottom := destRect.bottom + 8;						if (destRect.top > 342) then						begin							phase := 0;							OffAMortal;						end;					end;				end;		{end - shred}				otherwise			end;	end;{=================================}	procedure LetsPause;	begin		if (smsIsActive) then			SMSExit;		smsIsActive := FALSE;		demoMode := Randomize(lastDemo) + 1;		pausing := TRUE;		ForceMainToVisible;		InitCursor;		ShowMenuBar;		SetItem(GetMenu(mGame), iBegin, 'Continue Game');		DrawMenuBar;		FlushEvents(everyEvent, 0);		theErr := PostEvent(KeyDown, 65);	end;{=================================}	procedure LetsQuit;	begin		ForceMainToVisible;		ShowMenuBar;{$IFC DemoVersion}		playing := FALSE;		pausing := FALSE;		doneFlag := TRUE;{$ELSEC}		if DoQuit then		begin			playing := FALSE;			pausing := FALSE;			doneFlag := TRUE;		end		else		begin			if (SaveGame) then			begin				playing := FALSE;				pausing := FALSE;				doneFlag := TRUE;			end			else			begin				SetCursor(noCursor^^);				SetPort(GrafPtr(mainWndo));				BeginUpdate(GrafPtr(mainWndo));				if (inColor) then					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, nil)				else					CopyBits(offVirginMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, nil);				EndUpdate(GrafPtr(mainWndo));				if (inColor) then					SetPort(GrafPtr(virginCPtr))				else					SetPort(offVirginPort);			end;		end;{$ENDC}	end;{=================================}	procedure LetsSave;	begin{$IFC not DemoVersion}		InitCursor;		SpinBall;		ForceMainToVisible;		if (not SaveGame) then			;		SpinBall;		SetCursor(noCursor^^);		SetPort(GrafPtr(mainWndo));		BeginUpdate(GrafPtr(mainWndo));		if (inColor) then			CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, GrafPtr(mainWndo)^.portBits, wholeArea, wholeArea, srcCopy, nil)		else			CopyBits(offVirginMap, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, nil);		EndUpdate(GrafPtr(mainWndo));		if (inColor) then			SetPort(GrafPtr(virginCPtr))		else			SetPort(offVirginPort);{$ENDC}	end;{=================================}	procedure LetsEnd;	begin		SetItem(GetMenu(mGame), iBegin, 'Begin Game');		WrapItUp;		DrawMenuBar;	end;{=================================}	procedure Coordinate;		var			i: Integer;	begin		GetKeys(theKeys);		while ((playing) and (not pausing)) do		begin			timeIs := TickCount;			liftAmount := 2;			binaryFlip := BitXOr(binaryFlip, 1);			if (bandBorne) then				HandleBand;			if (lifeNormal) then			begin				SearchRects;				GetKeys(theKeys);				GetInput;				MoveGlider;			end			else				DoSpecial;			if (playing) then			begin				if (nAnimates > 0) then					MoveAnimates;				if (nCycleObs > 0) then					MoveCycleObs;				if (hasWindow) then					MonitorStorm;				if (areFlipping) then					DrawFlipScene				else				begin					if (inColor) then						DrawCScene					else						DrawScene;				end;				if (scoreIsRolling) then					BumpTheScore;			end;			if (theKeys[kCommandKeyMap]) and (theKeys[kQKeyMap]) then				LetsQuit;			if (theKeys[kCommandKeyMap]) and (theKeys[kSKeyMap]) then				LetsSave;			if (theKeys[kCommandKeyMap]) and (theKeys[kEKeyMap]) then				LetsEnd;			if (theKeys[kTabKeyMap]) then				LetsPause;			SetCursor(noCursor^^);			repeat			until (TickCount >= (timeIs + 2));			loopsThruRoom := loopsThruRoom + 1;			bassLoop := bassLoop + 1;			if (bassLoop >= playBassTime) then			begin				bassLoop := 0;				DoTheBass(kDuhDumSound);				playBassTime := (kBonusTimeToBeat - loopsThruRoom) div kBassFract + kMinBassLoop;				if (playBassTime < kMinBassLoop) then					playBassTime := kMinBassLoop;			end;		end;		FlushEvents(everyEvent, 0);		InitCursor;		DrawMenuBar;		if (scoreList.rank <> 20) then			DrawHiScores;	end;{=================================}end.